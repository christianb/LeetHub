{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww22740\viewh14660\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 import java.util.*\
\
/**\
 * Implementation of Topological Sorting using Kahn's Algorithm (BFS).\
 *\
 * Topological Sorting is an ordering of vertices in a directed acyclic graph (DAG) such that \
 * for every directed edge u -> v, vertex u comes before vertex v in the ordering.\
 *\
 * Kahn's Algorithm uses a Breadth-First Search (BFS) approach to achieve topological sorting.\
 *\
 * **Algorithm Overview:**\
 * 1. Compute the in-degree (number of incoming edges) for each vertex.\
 * 2. Enqueue all vertices with an in-degree of 0 (no dependencies).\
 * 3. While the queue is not empty:\
 *      - Dequeue a vertex and add it to the topological order.\
 *      - For each outgoing edge from the dequeued vertex, reduce the in-degree of the target vertex by 1.\
 *      - If the in-degree of the target vertex becomes 0, enqueue it.\
 * 4. If the number of vertices in the topological order is less than the total vertices in the graph, a cycle exists.\
 *\
 * **Parameters:**\
 * @param graph A map representing the directed graph where keys are vertices and values are lists of adjacent vertices.\
 *\
 * **Returns:**\
 * A list of vertices in topological order. If the graph contains a cycle, an exception is thrown.\
 *\
 * **Complexity:**\
 * - Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges, \
 *   as we process each vertex and edge once.\
 * - Space Complexity: O(V), for storing the in-degree array and the queue.\
 *\
 * **Use Case:**\
 * Topological sorting is used in:\
 * - Task scheduling where certain tasks must be completed before others (e.g., job scheduling).\
 * - Dependency resolution in build systems (e.g., resolving package dependencies in software builds).\
 * - Compilation processes where source files depend on each other.\
 * \
 * **Throws:**\
 * IllegalArgumentException if the graph contains a cycle, as topological sorting is not possible in cyclic graphs.\
 */\
fun topologicalSortKahn(graph: Map<Int, List<Int>>): List<Int> \{\
    // Step 1: Compute in-degree for each vertex\
    val inDegree = mutableMapOf<Int, Int>().withDefault \{ 0 \}\
    for (vertex in graph.keys) \{\
        for (neighbor in graph[vertex] ?: emptyList()) \{\
            inDegree[neighbor] = inDegree.getValue(neighbor) + 1\
        \}\
        inDegree.putIfAbsent(vertex, 0)\
    \}\
\
    // Step 2: Initialize queue with vertices having in-degree 0\
    val queue: Queue<Int> = LinkedList()\
    for ((vertex, degree) in inDegree) \{\
        if (degree == 0) queue.add(vertex)\
    \}\
\
    // Step 3: Process the graph using BFS\
    val topologicalOrder = mutableListOf<Int>()\
    while (queue.isNotEmpty()) \{\
        val current = queue.poll()\
        topologicalOrder.add(current)\
\
        // Reduce in-degree for all neighbors\
        for (neighbor in graph[current] ?: emptyList()) \{\
            inDegree[neighbor] = inDegree.getValue(neighbor) - 1\
            if (inDegree.getValue(neighbor) == 0) \{\
                queue.add(neighbor)\
            \}\
        \}\
    \}\
\
    // Step 4: Check for cycles\
    if (topologicalOrder.size != inDegree.size) \{\
        throw IllegalArgumentException("The graph contains a cycle; topological sorting is not possible.")\
    \}\
\
    return topologicalOrder\
\}\
\
// Example Usage:\
fun main() \{\
    val graph = mapOf(\
        1 to listOf(2, 3),\
        2 to listOf(4),\
        3 to listOf(4),\
        4 to listOf()\
    )\
    println(topologicalSortKahn(graph)) // Output: [1, 2, 3, 4] or [1, 3, 2, 4]\
\}\
}